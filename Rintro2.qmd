# Data structures

So far we've only looked at simple variables consisting of a single value or character. Typically, your data will be more complex. In `R`, there are three structures relevant for the data you will be working with.

## Vectors

A **vector** is a number of elements of the same data type (`logical`, `numeric`, `character`). It can be generated by concatenating the elements using the function `c`.

```{r}
vec1 <- c(T, F, T, F)
vec1
mode(vec1)

vec2 <- c(1, 2, 3, 4, 5)
vec2
mode(vec2)

vec3 <- c("Spring", "Summer", "Autumn", "Winter")
vec3
mode(vec3)
```

Other ways to generate vectors are `rep` and `seq`. `rep` is used to repeat any number of elements any number of times.

```{r}
rep(5, 10)

rep(vec3, 5)
```

`seq` can be used to create numerical sequences.

```{r}
seq(from = 0, to = 100, by = 5)
```

The command above is easy to read and understand for humans, which is good. `R` will also understand if you specify it as

```{r}
seq(0, 100, 5)
```

As a shortcut for a common sequences, you can use

```{r}
1:10
```

As mentioned above,, vectors can only combine elements of a single data type. Combining multiple different data types may result in some unwanted behaviour.

```{r}
vec_mix1 <- c(5, TRUE, 65)
mode(vec_mix1)

vec_mix2 <- c("blue", TRUE, "red")
mode(vec_mix2)
```

In many cases you may wish to access a single element of a vector. You can do so using square brackets.

```{r}
z <- c("order", "family", "genus", "species")
z[2]
```

Similarly, you can access any combination of elements from the vector.

```{r}
z[1:2]
i <- c(1, 3)
z[i]
z[c(1, 1, 1, 4)]
z[-1]
```

The square brackets are also used if you need to change elements of the vector. Changes are made using the assignment operator which you already know.

```{r}
x <- 1:5
x

x[c(1, 4)] <- 10
x
```

Which elements of a vector have certain characteristics? This is important for filtering/selecting in your dataset. You can combine different queries using logical operators.

```{r}
x >= 5
x[x >= 5]
which(x >= 5)

z
which(z == "genus")
z[z== "genus"]
z[z != "genus"]
which(z== "genus" | z == "order")
```

Logical operators in `R`

|     |     |
|-----|-----|
| `|` | OR  |
| `&` | AND |
| `!` | NOT |

Conveniently, the elements of a vector can be named and accessed using the names. Let's first create a vector...

```{r}
dmel <- c("Hexapoda", "Diptera", "Drosophilidae", "Drosophila", "Drosophila melanogaster")
dmel
```

... and then add names for each element

```{r}
names(dmel) <- c("Class", "Order", "Family", "Genus", "Species")
dmel
str(dmel)
```

Now we can use the names to access the values

```{r}
dmel[c("Class", "Species")]
dmel[names(dmel) == "Order"]
```

### Exercise {.unnumbered}

a)  Create a vector consecutively numbering all days of the year 2026. Assign the correct weekday names for all elements of the vector.

b)  Use the vector to determine how many days in 2026 are weekend days.

::: callout-tip
## Tip

If you struggle to assign the correct names, have a look at the help for `rep`.
:::

## Matrices

A **matrix** in `R` can be thought of as a two-dimensional vector. All elements must be of the same data type. There are various ways to create a matrix. For example, one can use the `matrix` function like this.

```{r}
mat1 <- matrix(data = 1:12, nrow = 3, ncol = 4, byrow=T) 
mat1
```

Alternatively, a vector can be transformed into a matrix

```{r}
mat2 <- 1:12
dim(mat2) <- c(3, 4)
mat2
```

Often you will want to combine multiple vectors into a matrix

```{r}
dmel <- c("Hexapoda", "Diptera", "Drosophilidae", "Drosophila", "Drosophila melanogaster")
dhyd <- c("Hexapoda", "Diptera", "Drosophilidae", "Drosophila", "Drosophila hydei")
mat3 <- cbind(dmel, dhyd)
mat3
mat4 <- rbind(dmel, dhyd)
mat4
```

Just like vectors, matrix elements can have names

```{r}
mat3
colnames(mat3)
rownames(mat3) <- c("Class", "Order", "Family", "Genus", "Species")
mat3
```

And just like with vectors, we can use square brackets to access and replace values. Because there are 2 dimensions, we need to provide 2 values (one for rows, one for columns, separated by `,`).

```{r}
mat3
mat3[1:3, 2]
mat3[1:3, ]
mat3[c("Class", "Species"), ]
```

### Exercise {.unnumbered}

a)  create a matrix using with 20 rows & 5 columns, using 100 randomly generated numbers between 0 and 1000.

```{r}


random_numbers <- runif(100, 0, 1000)


matrix(data = runif(100, 0, 1000), nrow = 20)



```

b)  replace all values in the 3rd column of this matrix that are larger than 500 with `NA`.

::: callout-tip
## Tip

use the function `runif` to create random values
:::

## Data frames

**Data frames** are the `R` equivalent of spread sheets. Like matrices, they are two-dimensional, however they may combine different data types. Most biological data sets you will encounter will be data frames.

Lets create a data frame

```{r}
# create some data
species <- rep(c("beech","ash","elm","maple", "sycamore"),40)
species
dbh <- runif(200, 5, 40)
dbh
age <- as.integer(runif(200, 20, 120))
age
df1 <- data.frame(species, dbh, age)
df1
```

To access values, we can use the same approaches as for matrices:

```{r}
df1[1:12, 1:2]
```

but can also access and filter the columns directly using their names like this:

```{r}
df1$species
df1[df1$dbh > 15, ]
```

### Exercise {.unnumbered}

a)  Using `df1`, select only entries corresponding to ash and maple with an age over 50 and a diameter less than 30.

b)  Add a new column to the dataframe called "year". Generate data for this column so that there are 10 different years and the same number of entries for each tree species per year.

```{r}

df1

year <- rep(2015:2024, 20)

df1[,4] <- year

colnames(df1)[4] <- "year"


df1
```

::: callout-tip
## Tip

Use the function `rep` for this exercise
:::
